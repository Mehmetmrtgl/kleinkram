import { redis } from '@common/consts';
import ActionTemplateEntity from '@common/entities/action/action-template.entity';
import ActionEntity from '@common/entities/action/action.entity';
import MissionEntity from '@common/entities/mission/mission.entity';
import UserEntity from '@common/entities/user/user.entity';
import WorkerEntity from '@common/entities/worker/worker.entity';
import { ActionState } from '@common/frontend_shared/enum';
import { addActionQueue } from '@common/scheduling-logic';
import {
    ConflictException,
    Injectable,
    Logger,
    OnModuleInit,
} from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { InjectRepository } from '@nestjs/typeorm';
import { InjectMetric } from '@willsoto/nestjs-prometheus';
import Queue from 'bull';
import { Gauge } from 'prom-client';
import { EntityManager, LessThan, Repository } from 'typeorm';

@Injectable()
export class ActionDispatcherService implements OnModuleInit {
    private readonly logger = new Logger(ActionDispatcherService.name);
    private actionQueues: Record<string, Queue.Queue> = {};

    constructor(
        @InjectRepository(ActionEntity)
        private actionRepository: Repository<ActionEntity>,
        @InjectRepository(ActionTemplateEntity)
        private actionTemplateRepository: Repository<ActionTemplateEntity>,
        @InjectRepository(WorkerEntity)
        private workerRepository: Repository<WorkerEntity>,
        @InjectMetric('backend_online_workers')
        private onlineWorkers: Gauge,
        @InjectMetric('backend_pending_jobs')
        private pendingJobs: Gauge,
        @InjectMetric('backend_active_jobs')
        private activeJobs: Gauge,
        @InjectMetric('backend_completed_jobs')
        private completedJobs: Gauge,
        @InjectMetric('backend_failed_jobs')
        private failedJobs: Gauge,
    ) {}

    async onModuleInit(): Promise<void> {
        const availableWorkers = await this.workerRepository.find({
            where: { reachable: true },
        });

        this.actionQueues = {};

        // Initialize queues for all reachable workers
        try {
            await Promise.all(
                availableWorkers.map(async (worker) => {
                    this.actionQueues[worker.identifier] = new Queue(
                        `action-queue-${worker.identifier}`,
                        { redis },
                    );
                    await this.actionQueues[worker.identifier]?.isReady();
                }),
            );
            this.logger.log('Action Queues initialized');
        } catch (error) {
            this.logger.error('Failed to initialize action queues', error);
        }

        // Update metrics immediately
        this.onlineWorkers.set({}, availableWorkers.length);
    }

    /**
     * Core dispatch logic: Creates entity and schedules on Bull queue
     */
    async dispatch(
        templateUuid: string,
        mission: MissionEntity,
        creator: UserEntity,
        parameters: Record<string, any>,
    ): Promise<string> {
        const template = await this.actionTemplateRepository.findOneOrFail({
            where: { uuid: templateUuid },
        });

        let action = this.actionRepository.create({
            mission,
            creator,
            state: ActionState.PENDING,
            template,
        });
        action = await this.actionRepository.save(action);

        try {
            const runtimeRequirements = {
                cpuCores: template.cpuCores,
                cpuMemory: template.cpuMemory,
                gpuMemory: template.gpuMemory,
                maxRuntime: template.maxRuntime,
                ...parameters,
            };

            // - Passing this.actionQueues which is now managed here
            const queued = await addActionQueue(
                action,
                runtimeRequirements,
                this.workerRepository,
                this.actionRepository,
                this.actionQueues,
                this.logger,
            );

            if (!queued) throw new Error('Queue rejection');

            this.logger.log(
                `Action ${action.uuid} dispatched for mission ${mission.uuid}`,
            );
            return action.uuid;
        } catch (error) {
            this.logger.error(`Failed to queue action ${action.uuid}`, error);
            await this.actionRepository.update(action.uuid, {
                state: ActionState.UNPROCESSABLE,
                state_cause: 'Resources unavailable or queue error',
            });
            throw new ConflictException('No worker available');
        }
    }

    /**
     * Stops a running action by removing it from the specific worker queue
     */
    async stopAction(actionRunId: string): Promise<void> {
        let actionIdentifier: string | undefined = undefined;

        await this.actionRepository.manager.transaction(
            async (manager: EntityManager): Promise<void> => {
                const action = await manager.findOne(ActionEntity, {
                    where: { uuid: actionRunId },
                    relations: ['worker'],
                });

                if (action?.worker === undefined)
                    throw new Error('No worker found for this action');

                action.state = ActionState.FAILED;
                await manager.save(action);
                actionIdentifier = action.worker.identifier;
            },
        );

        if (actionIdentifier === undefined)
            throw new ConflictException('Action or Worker not found');

        const queue = this.actionQueues[actionIdentifier];
        if (!queue) throw new ConflictException('Worker queue not active');

        const job = await queue.getJob(actionRunId);
        if (!job) {
            this.logger.warn(`Job ${actionRunId} not found in queue to stop`);
            return;
        }

        await job.remove();
        this.logger.log(`Action ${actionRunId} stopped successfully`);
    }

    /**
     * Checks for unreachable workers and re-queues their pending jobs
     */
    @Cron(CronExpression.EVERY_30_SECONDS)
    async healthCheck() {
        // Find workers that have timed out
        const workers = await this.workerRepository.find({
            where: {
                reachable: true,
                lastSeen: LessThan(new Date(Date.now() - 2 * 60 * 1000)),
            },
        });

        await Promise.all(
            workers.map(async (worker) => {
                this.logger.warn(`${worker.identifier} is now unreachable`);
                worker.reachable = false;
                await this.workerRepository.save(worker);

                const actionQueue = this.actionQueues[worker.identifier];
                if (!actionQueue) return;

                try {
                    // Retrieve jobs that were assigned to this dead worker
                    const waitingJobs = await actionQueue.getJobs([
                        'active',
                        'delayed',
                        'waiting',
                    ]);

                    await Promise.all(
                        waitingJobs.map(async (job) => {
                            try {
                                const action =
                                    await this.actionRepository.findOneOrFail({
                                        where: { uuid: job.data.uuid },
                                        relations: ['template'],
                                    });

                                await job.remove();

                                // Re-schedule logic
                                const runtimeRequirements = {
                                    cpuCores: action.template?.cpuCores ?? 1,
                                    cpuMemory:
                                        action.template?.cpuMemory ?? 512,
                                    gpuMemory: action.template?.gpuMemory ?? -1,
                                    maxRuntime:
                                        action.template?.maxRuntime ?? 4,
                                };

                                this.logger.log(
                                    `Re-queueing action ${action.uuid} from dead worker`,
                                );

                                //
                                await addActionQueue(
                                    action,
                                    runtimeRequirements,
                                    this.workerRepository,
                                    this.actionRepository,
                                    this.actionQueues,
                                    this.logger,
                                );
                            } catch (error) {
                                this.logger.error(
                                    `Failed to re-queue job ${job.id}`,
                                    error,
                                );
                            }
                        }),
                    );

                    // Clean up the local queue reference
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete this.actionQueues[worker.identifier];
                } catch (error) {
                    this.logger.error(
                        `Error handling dead worker ${worker.identifier}`,
                        error,
                    );
                }
            }),
        );

        // Re-initialize queues for reachable workers (in case new ones appeared)
        const activeWorker = await this.workerRepository.find({
            where: { reachable: true },
        });

        for (const worker of activeWorker) {
            if (!this.actionQueues[worker.identifier]) {
                this.actionQueues[worker.identifier] = new Queue(
                    `action-queue-${worker.identifier}`,
                    { redis },
                );
            }
        }

        this.onlineWorkers.set({}, activeWorker.length);
    }

    /**
     * Updates Prometheus metrics for Action Queues
     */
    @Cron(CronExpression.EVERY_SECOND)
    async checkQueueState(): Promise<void> {
        const queues = Object.values(this.actionQueues);

        const jobCounts = await Promise.all(
            queues.map((q) => q.getJobCounts()),
        );

        for (const [index, count] of jobCounts.entries()) {
            const queueName = queues[index]?.name;
            this.pendingJobs.set(
                { queue: queueName },
                count.waiting + count.delayed,
            );
            this.activeJobs.set({ queue: queueName }, count.active);
            this.completedJobs.set({ queue: queueName }, count.completed);
            this.failedJobs.set({ queue: queueName }, count.failed);
        }
    }

    // Helper to inspect queues (used by API)
    async getAllJobs(): Promise<any[]> {
        const jobs: any[] = [];
        for (const queue of Object.values(this.actionQueues)) {
            const _jobs = await queue.getJobs([
                'active',
                'delayed',
                'waiting',
                'completed',
                'failed',
            ]);
            jobs.push(..._jobs);
        }
        return jobs;
    }
}
