import { SortOrder } from '@common/api/types/pagination';
import { UpdateFile } from '@common/api/types/update-file.dto';
import FileEntity from '@common/entities/file/file.entity';
import MissionEntity from '@common/entities/mission/mission.entity';
import ProjectEntity from '@common/entities/project/project.entity';
import env from '@common/environment';
import {
    DataType,
    FileEventType,
    FileOrigin,
    FileState,
    FileType,
    HealthStatus,
    UserRole,
} from '@common/frontend_shared/enum';
import {
    BadRequestException,
    Injectable,
    NotFoundException,
    OnModuleInit,
    UnsupportedMediaTypeException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import {
    Brackets,
    DataSource,
    In,
    MoreThan,
    Repository,
    SelectQueryBuilder,
} from 'typeorm';
import { fileEntityToDto, fileEntityToDtoWithTopic } from '../serialization';
import {
    addFileFilters,
    addMissionFilters,
    addProjectFilters,
    addSort,
} from './utilities';

import {
    FileExistsResponseDto,
    TemporaryFileAccessDto,
    TemporaryFileAccessesDto,
} from '@common/api/types/file/access.dto';
import { FileEventsDto } from '@common/api/types/file/file-event.dto';
import { FileWithTopicDto } from '@common/api/types/file/file.dto';
import { FilesDto } from '@common/api/types/file/files.dto';
import { StorageOverviewDto } from '@common/api/types/storage-overview.dto';
import { FileAuditService } from '@common/audit/file-audit.service';
import { redis } from '@common/consts';
import CategoryEntity from '@common/entities/category/category.entity';
import FileEventEntity from '@common/entities/file/file-event.entity';
import IngestionJobEntity from '@common/entities/file/ingestion-job.entity';
import TagTypeEntity from '@common/entities/tagType/tag-type.entity';
import UserEntity from '@common/entities/user/user.entity';
import { StorageService } from '@common/modules/storage/storage.service';
import Queue from 'bull';
import Credentials from 'minio/dist/main/Credentials';
import { BucketItem } from 'minio/dist/main/internal/type';
import {
    addAccessConstraints,
    addAccessConstraintsToFileQuery,
} from '../endpoints/auth/auth-helper';
import logger from '../logger';

const FIND_MANY_SORT_KEYS = {
    name: 'file.filename',
    filename: 'file.filename',
    createdAt: 'file.createdAt',
    updatedAt: 'file.updatedAt',
    creator: 'user.name',
};

@Injectable()
export class FileService implements OnModuleInit {
    private fileCleanupQueue!: Queue.Queue;

    constructor(
        @InjectRepository(FileEntity)
        private fileRepository: Repository<FileEntity>,
        @InjectRepository(MissionEntity)
        private missionRepository: Repository<MissionEntity>,
        @InjectRepository(ProjectEntity)
        private projectRepository: Repository<ProjectEntity>,
        @InjectRepository(UserEntity)
        private userRepository: Repository<UserEntity>,
        private readonly dataSource: DataSource,
        @InjectRepository(TagTypeEntity)
        private tagTypeRepository: Repository<TagTypeEntity>,
        @InjectRepository(IngestionJobEntity)
        private queueRepository: Repository<IngestionJobEntity>,
        @InjectRepository(CategoryEntity)
        private categoryRepository: Repository<CategoryEntity>,
        private readonly storageService: StorageService,
        @InjectRepository(FileEventEntity)
        private eventRepo: Repository<FileEventEntity>,
        private readonly auditService: FileAuditService,
    ) {}

    onModuleInit(): void {
        this.fileCleanupQueue = new Queue('file-cleanup', {
            redis,
        });
    }

    async findMany(
        projectUuids: string[],
        projectPatterns: string[],
        missionUuids: string[],
        missionPatterns: string[],
        fileUuids: string[],
        filePatterns: string[],
        missionMetadata: Record<string, string>,
        sortBy: string | undefined,
        sortOrder: SortOrder,
        take: number,
        skip: number,
        userUuid: string,
    ): Promise<FilesDto> {
        let query = this.fileRepository
            .createQueryBuilder('file')
            .leftJoinAndSelect('file.mission', 'mission')
            .leftJoinAndSelect('mission.project', 'project')
            .leftJoinAndSelect('file.creator', 'creator');

        query = addAccessConstraintsToFileQuery(query, userUuid);

        query = addProjectFilters(
            query,
            this.projectRepository,
            projectUuids,
            projectPatterns,
        );

        query = addMissionFilters(
            query,
            this.missionRepository,
            missionUuids,
            missionPatterns,
            missionMetadata,
        );

        query = addFileFilters(
            query,
            this.fileRepository,
            fileUuids,
            filePatterns,
        );

        if (sortBy !== undefined) {
            query = addSort(query, FIND_MANY_SORT_KEYS, sortBy, sortOrder);
        }

        const [files, count] = await query
            .take(take)
            .skip(skip)
            .getManyAndCount();

        return {
            data: files.map((element) => fileEntityToDto(element)),
            count,
            take,
            skip,
        };
    }

    /**
     * Finds and paginates files based on a comprehensive set of filters.
     *
     * This method uses a two-query approach to correctly handle pagination with
     * complex joins and groupings (required for 'matchAll' topics and tags):
     * 1. The first query applies all filters and retrieves *only* the UUIDs
     * of the matching files for the requested page, along with the *total count*
     * of all matching files (pre-pagination).
     * 2. The second query fetches the full file entities (with relations) for
     * the UUIDs retrieved in the first query.
     */
    async findFiltered(
        fileName: string,
        projectUUID: string,
        missionUUID: string,
        startDate: Date | undefined,
        endDate: Date | undefined,
        topics: string,
        categories: string,
        matchAllTopics: boolean,
        fileTypes: string,
        tags: Record<string, any>,
        userUUID: string,
        take: number,
        skip: number,
        sort: string,
        sortOrder: 'ASC' | 'DESC',
        health: HealthStatus,
    ): Promise<FilesDto> {
        const user = await this.userRepository.findOneOrFail({
            where: { uuid: userUUID },
        });

        // Start building the query to fetch *only* IDs
        let idQuery = this.fileRepository
            .createQueryBuilder('file')
            .select('file.uuid') // Select only the UUID
            .leftJoin('file.mission', 'mission')
            .leftJoin('mission.project', 'project')
            .leftJoin('file.topics', 'topic'); // Joined for filtering

        // ADMIN users see all, others are constrained
        if (user.role !== UserRole.ADMIN) {
            idQuery = addAccessConstraints(idQuery, userUUID);
        }

        // Apply simple filters
        if (fileName) {
            logger.debug(`Filtering files by filename: ${fileName}`);
            idQuery.andWhere('file.filename LIKE :fileName', {
                fileName: `%${fileName}%`,
            });
        }

        if (projectUUID) {
            logger.debug(`Filtering files by projectUUID: ${projectUUID}`);
            idQuery.andWhere('project.uuid = :projectUUID', { projectUUID });
        }

        if (missionUUID) {
            logger.debug(`Filtering files by missionUUID: ${missionUUID}`);
            idQuery.andWhere('mission.uuid = :missionUUID', { missionUUID });
        }

        if (startDate && endDate) {
            logger.debug(
                `Filtering files by date range: ${startDate.toString()} - ${endDate.toString()}`,
            );
            idQuery.andWhere('file.date BETWEEN :startDate AND :endDate', {
                startDate,
                endDate,
            });
        }

        // Apply complex filters via helper methods
        this._applyFileTypeFilter(idQuery, fileTypes);
        this._applyTopicFilter(idQuery, topics, matchAllTopics);

        if (health) {
            logger.debug(`Filtering files by health: ${health}`);
            switch (health) {
                case HealthStatus.HEALTHY: {
                    idQuery.andWhere('file.state IN (:...healthyStates)', {
                        healthyStates: [FileState.OK, FileState.FOUND],
                    });
                    break;
                }
                case HealthStatus.UNHEALTHY: {
                    idQuery.andWhere('file.state IN (:...unhealthyStates)', {
                        unhealthyStates: [
                            FileState.ERROR,
                            FileState.CONVERSION_ERROR,
                            FileState.LOST,
                            FileState.CORRUPTED,
                        ],
                    });
                    break;
                }
                case HealthStatus.UPLOADING: {
                    idQuery.andWhere('file.state = :uploadingState', {
                        uploadingState: FileState.UPLOADING,
                    });
                    break;
                }
            }
        }

        const categoryUUIDs = categories ? categories.split(',') : [];
        if (categoryUUIDs.length > 0) {
            logger.debug(`Filtering files by categories: ${categories}`);
            idQuery
                .innerJoin('file.categories', 'category')
                .andWhere('category.uuid IN (:...categoryUUIDs)', {
                    categoryUUIDs,
                });
        }

        // The tag filter is async, so it must be awaited
        if (tags && Object.keys(tags).length > 0) {
            await this._applyTagFilter(idQuery, tags);
        }

        // Group by file.uuid to deduplicate results from joins
        // and allow 'HAVING' clauses for topics and tags
        idQuery.groupBy('file.uuid');

        idQuery.orderBy(sort, sortOrder).offset(skip).limit(take);

        const [fileIdObjects, count] = await idQuery.getManyAndCount();

        if (fileIdObjects.length === 0) {
            logger.silly('No files found');
            return {
                count,
                data: [],
                take,
                skip,
            };
        }

        const fileIds = fileIdObjects.map((file) => file.uuid);

        // It must re-apply joins (for selection) and sorting.
        const files = await this.fileRepository
            .createQueryBuilder('file')
            .leftJoinAndSelect('file.mission', 'mission')
            .leftJoinAndSelect('mission.project', 'project')
            .leftJoinAndSelect('file.topics', 'topic')
            .leftJoinAndSelect('file.creator', 'creator')
            .leftJoinAndSelect('file.categories', 'category')
            .where('file.uuid IN (:...fileIds)', { fileIds })
            .orderBy(sort, sortOrder)
            .getMany();

        return {
            count,
            data: files.map((element) => fileEntityToDto(element)),
            take,
            skip,
        };
    }

    /**
     * Applies file type filtering to the query.
     */
    private _applyFileTypeFilter(
        query: SelectQueryBuilder<FileEntity>,
        fileTypes: string,
    ): void {
        if (!fileTypes) {
            return;
        }

        const requestedTypes = fileTypes.split(',');
        const requestedTypesUpper = requestedTypes.map((t) => t.toUpperCase());

        // If 'ALL' is requested, do nothing (apply no filter)
        if (requestedTypesUpper.includes(FileType.ALL)) {
            return;
        }

        // Build a lookup map of valid enum values (e.g., "mcap" -> "MCAP")
        const validTypesLookup = new Map<string, string>();
        for (const type of Object.values(FileType).filter(
            (_type) => _type !== FileType.ALL,
        )) {
            validTypesLookup.set(type.toLowerCase(), type);
        }

        // Map requested types to their valid, cased enum values and deduplicate
        const typesToFilter = [
            ...new Set(
                requestedTypes
                    .map((requestType) =>
                        validTypesLookup.get(requestType.toLowerCase()),
                    )
                    .filter((type): type is string => !!type), // Filter out undefined
            ),
        ];

        if (typesToFilter.length > 0) {
            logger.debug(
                `Filtering files by types: ${typesToFilter.join(',')}`,
            );
            query.andWhere('file.type IN (:...fileTypes)', {
                fileTypes: typesToFilter,
            });
        } else {
            // No valid types were provided (e.g., "garbage,foo")
            logger.warn(`No valid file types found in filter: ${fileTypes}`);
            query.andWhere('1 = 0'); // Force query to return no results
        }
    }

    /**
     * Applies topic filtering to the query.
     */
    private _applyTopicFilter(
        query: SelectQueryBuilder<FileEntity>,
        topics: string,
        matchAllTopics: boolean,
    ): void {
        if (!topics) {
            return;
        }

        const splitTopics = topics.split(',').filter((t) => t.length > 0);
        if (splitTopics.length === 0) {
            return;
        }

        // Filter files that have *at least one* of the topics
        query.andWhere('topic.name IN (:...splitTopics)', {
            splitTopics,
        });

        // If 'matchAllTopics' is true, add a HAVING clause
        // to ensure the file has *all* requested topics.
        if (matchAllTopics) {
            query.having('COUNT(DISTINCT topic.name) = :topicCount', {
                topicCount: splitTopics.length,
            });
        }
    }

    /**
     * Applies tag filtering to the query.
     * This is the most complex filter, requiring a 'relational division' query.
     *
     * We find files where the mission has tags that match ALL specified conditions.
     * We do this by:
     * 1. Joining mission tags and tag types.
     * 2. Adding a WHERE clause: `(condition 1) OR (condition 2) OR ...`
     * 3. Adding a HAVING clause: `COUNT(DISTINCT matched_tag_types) = total_conditions`
     */
    private async _applyTagFilter(
        query: SelectQueryBuilder<FileEntity>,
        tags: Record<string, any>,
    ): Promise<void> {
        const tagTypeUUIDs = Object.keys(tags);
        if (tagTypeUUIDs.length === 0) {
            return;
        }

        const tagTypes = await this.tagTypeRepository.find({
            where: { uuid: In(tagTypeUUIDs) },
        });
        const tagTypeMap = new Map(tagTypes.map((t) => [t.uuid, t]));

        // Add the necessary joins for tag filtering
        query
            .leftJoin('mission.tags', 'tag')
            .leftJoin('tag.tagType', 'tagtype');

        const tagWhereClauses: string[] = [];
        const tagParameters = {};
        let validTagCount = 0;

        for (const uuid of tagTypeUUIDs) {
            const tagtype = tagTypeMap.get(uuid);
            if (!tagtype) {
                logger.warn(`Invalid tag type UUID in filter: ${uuid}`);
                continue;
            }

            const value = tags[uuid];
            const [column, processedValue] = this._getTagColumnAndValue(
                tagtype.datatype,
                value,
            );

            if (!column) {
                logger.warn(`Unknown data type for tag type ${uuid}`);
                continue;
            }

            // Create unique parameter names for this condition
            const uuidParameter = `tagtype${validTagCount}`;
            const valueParameter = `tagval${validTagCount}`;

            // Build the clause: (tagtype.uuid = :uuid AND tag.VALUE_COLUMN = :value)
            tagWhereClauses.push(
                `(tagtype.uuid = :${uuidParameter} AND tag.${column} = :${valueParameter})`,
            );
            tagParameters[uuidParameter] = uuid;
            tagParameters[valueParameter] = processedValue;

            validTagCount++;
        }

        if (validTagCount === 0) {
            // All provided tag filters were invalid
            query.andWhere('1 = 0'); // Return no results
            return;
        }

        query.andWhere(
            new Brackets((qb) => {
                for (const clause of tagWhereClauses) qb.orWhere(clause);
            }),
            tagParameters,
        );

        query.having('COUNT(DISTINCT tagtype.uuid) = :tagCount', {
            tagCount: validTagCount,
        });
    }

    /**
     * Helper to get the correct database column name based on
     * the tag's DataType.
     *
     * We store tag values in different columns based on their type in
     * order to support complex queries and indexing.
     *
     */
    private _getTagColumnAndValue<T>(
        dataType: DataType,
        value: T,
    ): [string | null, T | undefined] {
        switch (dataType) {
            case DataType.BOOLEAN: {
                return ['BOOLEAN', value];
            }
            case DataType.DATE: {
                return ['DATE', value];
            }
            case DataType.LOCATION: {
                return ['LOCATION', value];
            }
            case DataType.NUMBER: {
                return ['NUMBER', value];
            }
            case DataType.STRING:
            case DataType.LINK: {
                return ['STRING', value];
            }
            default: {
                return [null, undefined];
            }
        }
    }
    async findOne(uuid: string): Promise<FileWithTopicDto> {
        const file = await this.fileRepository.findOneOrFail({
            where: { uuid },
            relations: [
                'mission',
                'topics',
                'mission.project',
                'creator',
                'categories',
                'parent',
                'parent.topics',
                'derivedFiles',
                'derivedFiles.topics',
            ],
        });

        return fileEntityToDtoWithTopic(file);
    }

    async getFileEvents(fileUuid: string): Promise<FileEventsDto> {
        const events = await this.eventRepo.find({
            where: {
                file: { uuid: fileUuid },
            },
            relations: ['actor'],
            order: { createdAt: 'DESC' },
        });

        return {
            count: events.length,
            data:
                events.map((event) => ({
                    uuid: event.uuid,
                    type: event.type,
                    createdAt: event.createdAt,
                    details: event.details,
                    actor: event.actor
                        ? {
                              uuid: event.actor.uuid,
                              name: event.actor.name,
                          }
                        : undefined,
                })) ?? [],
        } as FileEventsDto;
    }

    /**
     * Updates a file with the given uuid.
     * @param uuid
     * @param file
     */
    /**
     * Updates a file with the given uuid.
     */
    async update(
        uuid: string,
        file: UpdateFile,
        actor?: UserEntity,
    ): Promise<FileEntity | null> {
        logger.debug(`Updating file with uuid: ${uuid}`);

        const databaseFile = await this.fileRepository.findOneOrFail({
            where: { uuid },
            relations: { mission: { project: true } },
        });

        if (!databaseFile.mission) throw new Error('Mission not found!');
        if (!databaseFile.mission.project)
            throw new Error('Project not found!');

        // [10x] Detect Rename
        const oldFilename = databaseFile.filename;
        const isRenamed = file.filename !== oldFilename;

        // validate file ending
        const fileEnding =
            databaseFile.type === FileType.MCAP ? '.mcap' : '.bag';
        if (!file.filename.endsWith(fileEnding)) {
            throw new BadRequestException('File ending must not be changed');
        }

        databaseFile.filename = file.filename;
        databaseFile.date = file.date;

        // Handle Mission Move via Update
        let oldMissionUuid: string | undefined;
        if (
            file.missionUuid &&
            file.missionUuid !== databaseFile.mission.uuid
        ) {
            oldMissionUuid = databaseFile.mission.uuid;
            const newMission = await this.missionRepository.findOneOrFail({
                where: { uuid: file.missionUuid },
                relations: ['project'],
            });
            if (newMission) databaseFile.mission = newMission;
        }

        if (file.categories) {
            databaseFile.categories = await this.categoryRepository.find({
                where: { uuid: In(file.categories) },
            });
        }

        await this.dataSource
            .transaction(async (transactionalEntityManager) => {
                // [Existing Transaction Logic]
                await transactionalEntityManager.save(FileEntity, databaseFile);
            })
            .catch((error: unknown) => {
                // [Existing Error Handling]
                throw error;
            });

        // Log Rename Event
        if (isRenamed) {
            await this.auditService.log(
                FileEventType.RENAMED,
                {
                    fileUuid: databaseFile.uuid,
                    filename: databaseFile.filename,
                    missionUuid: databaseFile.mission.uuid,
                    ...(actor ? { actor } : {}),
                    details: { oldFilename, newFilename: file.filename },
                },
                true,
            );
        }

        // Log Move Event (if done via update)
        if (oldMissionUuid) {
            await this.auditService.log(
                FileEventType.MOVED,
                {
                    fileUuid: databaseFile.uuid,
                    filename: databaseFile.filename,
                    missionUuid: databaseFile.mission.uuid,
                    ...(actor ? { actor } : {}),
                    details: {
                        fromMission: oldMissionUuid,
                        toMission: file.missionUuid,
                    },
                },
                true,
            );
        }

        await this.storageService.addTags(
            env.MINIO_DATA_BUCKET_NAME,
            databaseFile.uuid,
            {
                // @ts-expect-error
                projectUuid: databaseFile.mission.project.uuid,
                missionUuid: databaseFile.mission.uuid,
                filename: databaseFile.filename,
            },
        );
        return this.fileRepository.findOne({
            where: { uuid },
            relations: ['mission', 'mission.project'],
        });
    }

    /**
     * Generate a download link for a file with the given uuid.
     * The link will expire after 1 week if expires is set to true.
     *
     * @param uuid The unique identifier of the file
     * @param expires Whether the download link should expire
     */
    async generateDownload(
        uuid: string,
        expires: boolean,
        actor?: UserEntity,
    ): Promise<string> {
        // verify that an uuid is provided
        if (!uuid || uuid === '')
            throw new BadRequestException('UUID is required');

        const file = await this.fileRepository.findOneOrFail({
            where: { uuid },
        });

        // verify that the file exists in DB
        if (file.uuid === undefined || file.uuid !== uuid)
            throw new BadRequestException('File not found');

        const stats = await this.storageService.getFileInfo(
            env.MINIO_DATA_BUCKET_NAME,
            file.uuid,
        );

        // verify that the file exists in Minio
        if (!stats) throw new NotFoundException('File not found');

        await this.auditService.log(
            FileEventType.DOWNLOADED,
            {
                fileUuid: file.uuid,
                filename: file.filename,
                missionUuid: file.mission?.uuid ?? '',
                details: { expiresIn: expires ? '4 hours' : '1 week' },
                ...(actor ? { actor } : {}),
            },
            true,
        );

        return await this.storageService.getPresignedDownloadUrl(
            env.MINIO_DATA_BUCKET_NAME,
            file.uuid,
            expires ? 4 * 60 * 60 : 604_800,
            {
                // set filename in response headers
                'response-content-disposition': `attachment; filename ="${file.filename}"`,
            },
        );
    }

    async findOneByName(
        missionUUID: string,
        name: string,
    ): Promise<FileEntity | null> {
        return this.fileRepository.findOne({
            where: { mission: { uuid: missionUUID }, filename: name },
            relations: ['creator'],
        });
    }

    async moveFiles(
        fileUUIDs: string[],
        missionUUID: string,
        actor?: UserEntity,
    ): Promise<void> {
        await Promise.all(
            fileUUIDs.map(async (uuid) => {
                try {
                    const file = await this.fileRepository.findOneOrFail({
                        where: { uuid },
                        relations: ['mission'],
                    });

                    const oldMissionUuid = file.mission?.uuid;

                    file.mission = { uuid: missionUUID } as MissionEntity;
                    await this.fileRepository.save(file);

                    // Log Move Event
                    await this.auditService.log(
                        FileEventType.MOVED,
                        {
                            fileUuid: uuid,
                            filename: file.filename,
                            missionUuid: missionUUID,
                            ...(actor ? { actor } : {}),
                            details: {
                                fromMission: oldMissionUuid,
                                toMission: missionUUID,
                            },
                        },
                        true,
                    );

                    // ... [Existing Tag Update Logic] ...
                    const newFile = await this.fileRepository.findOneOrFail({
                        where: { uuid },
                        relations: ['mission', 'mission.project'],
                    });
                    await this.storageService.addTags(
                        env.MINIO_DATA_BUCKET_NAME,
                        file.uuid,
                        {
                            filename: file.filename,
                            missionUuid: missionUUID,
                            projectUuid: newFile.mission?.project?.uuid ?? '',
                        },
                    );
                } catch (error) {
                    logger.error(`Error moving file ${uuid}: ${error}`);
                }
            }),
        );
    }

    /**
     * Delete a file with the given uuid.
     * The file will be removed from the database and from Minio.
     *
     * @param uuid The unique identifier of the file
     * @param actor
     */
    async deleteFile(uuid: string, actor?: UserEntity): Promise<void> {
        if (!uuid) throw new BadRequestException('UUID is required');

        logger.debug(`Deleting file with uuid: ${uuid}`);

        // [10x] Log Deletion Intent BEFORE strict deletion
        // We need to fetch it first to have the metadata for the log
        const file = await this.fileRepository.findOne({
            where: { uuid },
            relations: ['mission'],
        });

        if (file) {
            await this.auditService.log(
                FileEventType.DELETED,
                {
                    fileUuid: uuid,
                    filename: file.filename,
                    missionUuid: file.mission?.uuid ?? '',
                    ...(actor ? { actor } : {}),
                    details: { snapshot: 'File deleted from DB and Storage' },
                },
                true,
            );
        }

        await this.fileRepository.manager.transaction(
            async (transactionalEntityManager) => {
                // [Existing Deletion Logic]
                const fileToDelete =
                    await transactionalEntityManager.findOneOrFail(FileEntity, {
                        where: { uuid },
                    });
                const bucket = env.MINIO_DATA_BUCKET_NAME;
                await this.storageService
                    .deleteFile(bucket, fileToDelete.uuid)
                    .catch(() => {
                        logger.error(
                            `File ${fileToDelete.uuid} not found in Minio, deleting from database only!`,
                        );
                    });

                await transactionalEntityManager.remove(fileToDelete);
            },
        );

        logger.debug(`File with uuid ${uuid} deleted`);
    }

    async getStorage(): Promise<StorageOverviewDto> {
        const metrics = await this.storageService.getSystemMetrics();

        return {
            usedBytes: metrics.minio_system_drive_used_bytes[0].value,
            totalBytes: metrics.minio_system_drive_total_bytes[0].value,
            usedInodes: metrics.minio_system_drive_used_inodes[0].value,
            totalInodes: metrics.minio_system_drive_total_inodes[0].value,
        } as StorageOverviewDto;
    }

    async isUploading(userUUID: string): Promise<boolean> {
        return this.fileRepository
            .findOne({
                where: {
                    state: FileState.UPLOADING,
                    createdAt: MoreThan(
                        new Date(Date.now() - 12 * 60 * 60 * 1000),
                    ),
                    creator: { uuid: userUUID },
                },
            })
            .then((r) => !!r);
    }

    /**
     * Get temporary access to upload files to Minio.
     * This function creates a new file entry in the database and a new queue entry.
     * The queue entry is used to track the upload progress.
     *
     * The function returns a list of access credentials for each file.
     *
     * @param filenames list of filenames to upload
     * @param missionUUID the mission to upload the files to
     * @param userUUID the user that is uploading the files
     */
    async getTemporaryAccess(
        filenames: string[],
        missionUUID: string,
        userUUID: string,
    ): Promise<TemporaryFileAccessesDto> {
        const mission = await this.missionRepository.findOneOrFail({
            where: { uuid: missionUUID },
            relations: ['project'],
        });
        const user = await this.userRepository.findOneOrFail({
            where: { uuid: userUUID },
        });

        const credentials = await Promise.all(
            filenames.map(async (filename) => {
                const emptyCredentials: {
                    bucket: string | null;
                    fileName: string;
                    fileUUID: string | null;
                    accessCredentials: Credentials | null;
                    error: string | null;
                    queueUUID?: string;
                } = {
                    // eslint-disable-next-line unicorn/no-null
                    bucket: null,
                    fileName: filename,
                    // eslint-disable-next-line unicorn/no-null
                    fileUUID: null,
                    // eslint-disable-next-line unicorn/no-null
                    accessCredentials: null,
                    // eslint-disable-next-line unicorn/no-null
                    error: null,
                };

                const fileExtensionToFileTypeMap: ReadonlyMap<
                    string,
                    FileType
                > = new Map([
                    ['.bag', FileType.BAG],
                    ['.mcap', FileType.MCAP],
                    ['.yaml', FileType.YAML],
                    ['.yml', FileType.YML],
                    ['.svo2', FileType.SVO2],
                    ['.tum', FileType.TUM],
                    ['.db3', FileType.DB3],
                ]);

                const supported_file_endings = [
                    ...fileExtensionToFileTypeMap.keys(),
                ];

                if (
                    !supported_file_endings.some((ending) =>
                        filename.endsWith(ending),
                    )
                ) {
                    emptyCredentials.error = 'Invalid file ending';
                    return emptyCredentials;
                }

                const matchingFileType = supported_file_endings.find((ending) =>
                    filename.endsWith(ending),
                );
                if (matchingFileType === undefined)
                    throw new UnsupportedMediaTypeException();
                const fileType: FileType | undefined =
                    fileExtensionToFileTypeMap.get(matchingFileType);
                if (fileType === undefined)
                    throw new UnsupportedMediaTypeException();

                // check if file already exists
                const existingFile = await this.fileRepository.exists({
                    where: {
                        filename,
                        mission: {
                            uuid: missionUUID,
                        },
                    },
                });
                if (existingFile) {
                    emptyCredentials.error = 'File already exists';
                    emptyCredentials.fileName = filename;
                    return emptyCredentials;
                }

                const file = await this.fileRepository.save(
                    this.fileRepository.create({
                        date: new Date(),
                        size: 0,
                        filename,
                        mission,
                        creator: user,
                        type: fileType,
                        state: FileState.UPLOADING,
                        origin: FileOrigin.UPLOAD,
                    }),
                );

                await this.auditService.log(
                    FileEventType.UPLOAD_STARTED,
                    {
                        fileUuid: file.uuid,
                        filename: file.filename,
                        missionUuid: missionUUID,
                        actor: user,
                        details: { origin: FileOrigin.UPLOAD },
                    },
                    true,
                );

                return {
                    bucket: env.MINIO_DATA_BUCKET_NAME,
                    fileUUID: file.uuid,
                    fileName: filename,
                    accessCredentials:
                        await this.storageService.generateTemporaryCredential(
                            file.uuid,
                            env.MINIO_DATA_BUCKET_NAME,
                        ),
                };
            }),
        );

        return {
            // TODO: fix typing
            data: credentials as unknown as TemporaryFileAccessDto[],
            count: credentials.length,
            skip: 0,
            take: credentials.length,
        };
    }

    async cancelUpload(
        uuids: string[],
        missionUUID: string,
        userUUID: string,
    ): Promise<Queue.Job> {
        // Cleanup cannot be done synchronously as this takes too long; the request is sent on unload; delaying the onUnload is difficult and discouraged
        return this.fileCleanupQueue.add('cancelUpload', {
            uuids,
            missionUUID,
            userUUID,
        });
    }

    async deleteMultiple(
        fileUUIDs: string[],
        missionUUID: string,
    ): Promise<void> {
        const uniqueFilesUuids = [...new Set(fileUUIDs)];

        await this.fileRepository.manager.transaction(
            async (transactionalEntityManager) => {
                const files = await transactionalEntityManager.find(
                    FileEntity,
                    {
                        where: {
                            uuid: In(uniqueFilesUuids),
                            mission: { uuid: missionUUID },
                        },
                    },
                );

                const uniqueDatabaseFilesUuids = [
                    ...new Set(files.map((f) => f.uuid)),
                ];
                if (
                    uniqueDatabaseFilesUuids.length !== uniqueFilesUuids.length
                ) {
                    throw new NotFoundException(
                        'Some files not found, aborting',
                    );
                }

                await Promise.all(
                    files.map(async (file) => {
                        const bucket = env.MINIO_DATA_BUCKET_NAME;
                        await this.storageService
                            .deleteFile(bucket, file.uuid)
                            .catch(() => {
                                logger.error(
                                    `File ${file.uuid} not found in Minio, deleting from database only!`,
                                );
                            });
                    }),
                );

                await transactionalEntityManager.remove(files);
            },
        );
    }

    async exists(fileUUID: string): Promise<FileExistsResponseDto> {
        return {
            exists: await this.fileRepository.exists({
                where: { uuid: fileUUID },
            }),
            uuid: fileUUID,
        };
    }

    async renameTags(bucket: string): Promise<void> {
        const filesList = await this.storageService.listFiles(bucket);

        await Promise.all(
            filesList.map(async (file: BucketItem): Promise<void> => {
                if (!file.name) {
                    logger.debug(`Filename is empty: ${JSON.stringify(file)}`);
                    return;
                }
                const fileEntity = await this.fileRepository.findOne({
                    where: { uuid: file.name },
                    relations: ['mission', 'mission.project'],
                });
                if (fileEntity === null) {
                    logger.error(`File ${file.name} not found in database`);
                    return;
                }

                await this.storageService.removeTags(bucket, file.name);

                if (fileEntity.mission === undefined)
                    throw new Error('Mission not found!');
                if (fileEntity.mission.project === undefined)
                    throw new Error('Project not found!');

                await this.storageService.addTags(bucket, file.name, {
                    projectUuid: fileEntity.mission.project.uuid,
                    missionUuid: fileEntity.mission.uuid,
                    filename: fileEntity.filename,
                });
            }),
        ).catch((error: unknown) => {
            logger.error(error);
        });
    }

    async recomputeFileSizes(): Promise<void> {
        const files = await this.fileRepository.find({
            where: {
                state: In([FileState.OK, FileState.FOUND]),
            },
        });
        await Promise.all(
            files.map(async (file) => {
                const stats = await this.storageService.getFileInfo(
                    file.type,
                    file.uuid,
                );

                if (stats) {
                    file.size = stats.size;
                    logger.debug(
                        `Updated size for ${file.filename}: ${file.size?.toString()}`,
                    );
                } else {
                    logger.error(
                        `File ${file.uuid} not found in Minio, setting state to LOST`,
                    );
                    file.state = FileState.LOST;
                }
                await this.fileRepository.save(file);
            }),
        );
    }
}
